## ğŸ“˜ DSA Sorting Algorithms Notes

---

### ğŸ”¹ 1. Bubble Sort

**ğŸ” Intuition:** Repeatedly swap adjacent elements if they are in the wrong order (like bubbles rising to the top).

**ğŸ“‹ Steps:**

```java
for (int i = 0; i < n - 1; i++) {
    for (int j = 0; j < n - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            // swap
        }
    }
}
```

**â±ï¸ Time & Space:**

* Best: O(n)
* Avg/Worst: O(nÂ²)
* Space: O(1)

**âœ… Stable:** Yes
**âœ… In-place:** Yes

**ğŸ§  Use-case:** Small datasets, good for learning.

**ğŸ§ª Dry Run:**
`[5, 1, 4, 2, 8]` â†’ passes explained step by step.

---

### ğŸ”¹ 2. Selection Sort

**ğŸ” Intuition:** Repeatedly find the minimum and place it at the correct index.

**ğŸ“‹ Steps:**

```java
for (int i = 0; i < n - 1; i++) {
    int minIdx = i;
    for (int j = i + 1; j < n; j++) {
        if (arr[j] < arr[minIdx])
            minIdx = j;
    }
    // swap arr[i] and arr[minIdx]
}
```

**â±ï¸ Time & Space:**

* Best/Average/Worst: O(nÂ²)
* Space: O(1)

**âŒ Stable:** No
**âœ… In-place:** Yes

**ğŸ§  Use-case:** When memory write operations are expensive.

---

### ğŸ”¹ 3. Insertion Sort

**ğŸ” Intuition:** Like sorting cards in your hand.

**ğŸ“‹ Steps:**

```java
for (int i = 1; i < n; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
    }
    arr[j + 1] = key;
}
```

**â±ï¸ Time & Space:**

* Best: O(n), Avg/Worst: O(nÂ²)
* Space: O(1)

**âœ… Stable:** Yes
**âœ… In-place:** Yes

**ğŸ§  Use-case:** Small or nearly sorted arrays.

---

### ğŸ”¹ 4. Merge Sort

**ğŸ” Intuition:** Divide and conquer â€“ split array, sort each part, and merge.

**ğŸ“‹ Steps:**

```java
void mergeSort(int[] arr, int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}
```

**â±ï¸ Time & Space:**

* All cases: O(n log n)
* Space: O(n)

**âœ… Stable:** Yes
**âŒ In-place:** No

**ğŸ§  Use-case:** Large datasets, external sorting.

---

### ğŸ”¹ 5. Quick Sort

**ğŸ” Intuition:** Partition array around a pivot.

**ğŸ“‹ Steps:**

```java
int partition(int[] arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            // swap arr[i], arr[j]
        }
    }
    // swap arr[i+1], arr[high]
    return i + 1;
}

void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

**â±ï¸ Time & Space:**

* Best/Average: O(n log n), Worst: O(nÂ²)
* Space: O(log n)

**âŒ Stable:** No
**âœ… In-place:** Yes

**ğŸ§  Use-case:** Fastest general-purpose sorting.

---

### ğŸ”¹ 6. Summary Table

| Algorithm   | Best       | Average    | Worst      | Space    | Stable | In-place |
| ----------- | ---------- | ---------- | ---------- | -------- | ------ | -------- |
| Bubble Sort | O(n)       | O(nÂ²)      | O(nÂ²)      | O(1)     | Yes    | Yes      |
| Selection   | O(nÂ²)      | O(nÂ²)      | O(nÂ²)      | O(1)     | No     | Yes      |
| Insertion   | O(n)       | O(nÂ²)      | O(nÂ²)      | O(1)     | Yes    | Yes      |
| Merge       | O(n log n) | O(n log n) | O(n log n) | O(n)     | Yes    | No       |
| Quick       | O(n log n) | O(n log n) | O(nÂ²)      | O(log n) | No     | Yes      |

---

### ğŸ”¹ 7. Advanced Sorts (Only When Needed)

* **Counting Sort:** O(n + k), good when range of data is small.
* **Radix Sort:** For sorting numbers with fixed digit length.
* **Bucket Sort:** When input is uniformly distributed.

---

### ğŸ”¹ 8. Problems to Practice

| Problem                               | Concept                 |
| ------------------------------------- | ----------------------- |
| Sort 0s, 1s, 2s (Dutch National Flag) | In-place categorization |
| Merge Intervals                       | Sorting + greedy        |
| Minimum Platforms                     | Sort start/end times    |
| Kth smallest pair                     | Binary search + sorting |
| Inversion Count                       | Merge Sort              |
